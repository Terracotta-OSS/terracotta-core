/*
 *
 *  The contents of this file are subject to the Terracotta Public License Version
 *  2.0 (the "License"); You may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *
 *  http://terracotta.org/legal/terracotta-public-license.
 *
 *  Software distributed under the License is distributed on an "AS IS" basis,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 *  the specific language governing rights and limitations under the License.
 *
 *  The Covered Software is Terracotta Core.
 *
 *  The Initial Developer of the Covered Software is
 *  Terracotta, Inc., a Software AG company
 *
 */
package com.tc.objectserver.locks;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.terracotta.entity.StateDumpCollector;
import org.terracotta.entity.StateDumpable;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.tc.async.api.Sink;
import com.tc.net.ClientID;
import com.tc.net.protocol.tcm.MessageChannel;
import com.tc.object.locks.ClientServerExchangeLockContext;
import com.tc.object.locks.LockID;
import com.tc.object.locks.ServerLockContext.Type;
import com.tc.object.locks.ServerLockLevel;
import com.tc.object.locks.ThreadID;
import com.tc.object.net.DSOChannelManager;
import com.tc.object.net.DSOChannelManagerEventListener;
import com.tc.objectserver.locks.LockStore.LockIterator;
import com.tc.objectserver.locks.ServerLock.NotifyAction;
import com.tc.objectserver.locks.factory.ServerLockFactoryImpl;
import com.tc.objectserver.locks.timer.LockTimer.LockTimerContext;
import com.tc.objectserver.locks.timer.TimerCallback;
import com.tc.text.PrettyPrinter;
import com.tc.util.Assert;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * LockManager is responsible for holding locks (in a LockStore) and delegating requests from the handler to the
 * concerned lock. Each lock is checked out, worked upon and then finally checked in.
 */
public class LockManagerImpl implements LockManager, StateDumpable, LockManagerMBean, TimerCallback, DSOChannelManagerEventListener {
  private enum RequestType {
    LOCK, TRY_LOCK, WAIT, UNLOCK
  }

  private final LockStore                               lockStore;
  private final DSOChannelManager                       channelManager;
  private final LockHelper                              lockHelper;
  private final ReentrantReadWriteLock                  statusLock       = new ReentrantReadWriteLock();
  private boolean                                       isStarted        = false;
  private final LinkedBlockingQueue<RequestLockContext> lockRequestQueue = new LinkedBlockingQueue<>();

  private static final Logger logger = LoggerFactory.getLogger(LockManagerImpl.class);

  public LockManagerImpl(Sink lockSink, DSOChannelManager channelManager) {
    this(lockSink, channelManager, new ServerLockFactoryImpl());
  }

  public LockManagerImpl(Sink lockSink, DSOChannelManager channelManager, LockFactory factory) {
    this.lockStore = new LockStore(factory);
    this.channelManager = channelManager;
    this.lockHelper = new LockHelper(lockSink, lockStore, this);
    channelManager.addEventListener(this);
  }

  @Override
  public void channelCreated(MessageChannel channel) {
  }

  @Override
  public void channelRemoved(MessageChannel channel, boolean wasActive) {
    clearAllLocksFor((ClientID) channel.getRemoteNodeID());
  }

  @Override
  public void lock(LockID lid, ClientID cid, ThreadID tid, ServerLockLevel level) {
    if (!queueIfNecessary(lid, cid, tid, level, RequestType.LOCK)) { return; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.lock(cid, tid, level, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void tryLock(LockID lid, ClientID cid, ThreadID tid, ServerLockLevel level, long timeout) {
    if (!queueIfNecessary(lid, cid, tid, level, RequestType.TRY_LOCK, timeout)) { return; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.tryLock(cid, tid, level, timeout, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void unlock(LockID lid, ClientID cid, ThreadID tid) {
    // This needs to be queueable since it maybe possible for an unpause race on the client side
    // to cause an unlock message to reach the server prior to the lock manager starting up. (see steps in wait()).
    if (!queueIfNecessary(lid, cid, tid, ServerLockLevel.WRITE, RequestType.UNLOCK)) { return; }

    // Lock might be removed from the lock store in the call to the unlock
    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.unlock(cid, tid, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void queryLock(LockID lid, ClientID cid, ThreadID tid) {
    if (!isValidStateFor(lid, cid, tid, "QueryLock")) { return; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.queryLock(cid, tid, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void interrupt(LockID lid, ClientID cid, ThreadID tid) {
    if (!isValidStateFor(lid, cid, tid, "Interrupt")) { return; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.interrupt(cid, tid, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  /*
   * Ignoring messages from client while in starting state. Such a case might come up when a recall timer goes out and
   * the lock is recalled by the client without it noticing that it might still be in paused state.
   */
  @Override
  public void recallCommit(LockID lid, ClientID cid, Collection<ClientServerExchangeLockContext> serverLockContexts) {
    if (!isStarted()) {
      logger.info("Ignoring recall commit messages from Client " + cid + " for Lock " + lid);
      return;
    }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.recallCommit(cid, serverLockContexts, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public NotifiedWaiters notify(LockID lid, ClientID cid, ThreadID tid, NotifyAction action,
                                NotifiedWaiters addNotifiedWaitersTo) {
    if (!isValidStateFor(lid, cid, tid, "Notify")) { return addNotifiedWaitersTo; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return addNotifiedWaitersTo; }
      return lock.notify(cid, tid, action, addNotifiedWaitersTo, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void wait(LockID lid, ClientID cid, ThreadID tid, long timeout) {
    // Why queue wait request?
    // consider steps:
    // 1) ClientLock trying to do remote wait
    // 2) Then that thread doesn't somehow doesn't get CPU cycles and before getting synchronized for wait
    // 3) Server crashes and transport is established again
    // 4) Client handshake gets called and it sends holder context to the server
    // 5) Then remote wait gets called and wait request gets queued in L2 Lock Manager
    // Hence the reason.
    if (!queueIfNecessary(lid, cid, tid, ServerLockLevel.WRITE, RequestType.WAIT, timeout)) { return; }

    ServerLock lock = lockStore.checkOut(lid);
    try {
      if (!isClientAlive(cid)) { return; }
      lock.wait(cid, tid, timeout, lockHelper);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  @Override
  public void reestablishState(ClientID cid, Collection<ClientServerExchangeLockContext> serverLockContexts) {
    assertStateIsStarting("Reestablish was called after the LockManager was started.");

    for (ClientServerExchangeLockContext cselc : serverLockContexts) {
      LockID lid = cselc.getLockID();

      Type type = cselc.getState().getType();
      switch (type) {
        case GREEDY_HOLDER:
        case HOLDER:
        case WAITER:
          ServerLock lock = lockStore.checkOut(lid);
          try {
            lock.reestablishState(cselc, lockHelper);
          } finally {
            lockStore.checkIn(lock);
          }
          break;
        case PENDING:
          lock(lid, (ClientID) cselc.getNodeID(), cselc.getThreadID(), cselc.getState().getLockLevel());
          break;
        case TRY_PENDING:
          tryLock(lid, (ClientID) cselc.getNodeID(), cselc.getThreadID(), cselc.getState().getLockLevel(),
                  cselc.timeout());
          break;
        default:
          throw new AssertionError(type);
      }
    }
  }

  @Override
  public void clearAllLocksFor(ClientID cid) {
    LockIterator iter = lockStore.iterator();
    ServerLock lock = iter.getNextLock(null);
    while (lock != null) {
      if (lock.clearStateForNode(cid, lockHelper)) {
        iter.remove();
      }
      lock = iter.getNextLock(lock);
    }
  }

  @Override
  public LockMBean[] getAllLocks() {
    List<LockMBean> beansList = new ArrayList<>();

    LockIterator iter = lockStore.iterator();
    ServerLock lock = iter.getNextLock(null);
    while (lock != null) {
      beansList.add(lock.getMBean(channelManager));
      lock = iter.getNextLock(lock);
    }

    return beansList.toArray(new LockMBean[beansList.size()]);
  }

  @Override
  public void start() {
    statusLock.writeLock().lock();
    try {
      Assert.assertTrue(!isStarted);
      isStarted = true;

      // Done to make sure that all wait/try timers are started
      lockHelper.getLockTimer().start();

      processPendingRequests();
    } finally {
      statusLock.writeLock().unlock();
    }
  }

  private void processPendingRequests() {
    RequestLockContext ctxt = null;
    while ((ctxt = lockRequestQueue.poll()) != null) {
      switch (ctxt.getType()) {
        case LOCK:
          lock(ctxt.getLockID(), ctxt.getClientID(), ctxt.getThreadID(), ctxt.getRequestedLockLevel());
          break;
        case TRY_LOCK:
          tryLock(ctxt.getLockID(), ctxt.getClientID(), ctxt.getThreadID(), ctxt.getRequestedLockLevel(),
                  ctxt.getTimeout());
          break;
        case WAIT:
          wait(ctxt.getLockID(), ctxt.getClientID(), ctxt.getThreadID(), ctxt.getTimeout());
          break;
        case UNLOCK:
          unlock(ctxt.getLockID(), ctxt.getClientID(), ctxt.getThreadID());
          break;
        default:
          throw new AssertionError(ctxt.getType());
      }
    }
  }

  @Override
  public void timerTimeout(LockTimerContext lockTimerContext) {
    LockID lid = lockTimerContext.getLockID();
    ServerLock lock = lockStore.checkOut(lid);
    try {
      // call timeout for the lock
      lock.timerTimeout(lockTimerContext);
    } finally {
      lockStore.checkIn(lock);
    }
  }

  private void queueRequest(LockID lid, ClientID cid, ThreadID tid, ServerLockLevel level, RequestType type,
                            long timeout) {
    RequestLockContext context = new RequestLockContext(lid, cid, tid, level, type, timeout);
    try {
      lockRequestQueue.put(context);
    } catch (InterruptedException e) {
      throw new AssertionError(e);
    }
  }

  private boolean queueIfNecessary(LockID lid, ClientID cid, ThreadID tid, ServerLockLevel level, RequestType type) {
    return queueIfNecessary(lid, cid, tid, level, type, -1);
  }

  private boolean queueIfNecessary(LockID lid, ClientID cid, ThreadID tid, ServerLockLevel level, RequestType type,
                                   long timeout) {
    statusLock.readLock().lock();
    try {
      if (!isStarted) {
        queueRequest(lid, cid, tid, level, type, timeout);
        return false;
      }
      return true;
    } finally {
      statusLock.readLock().unlock();
    }
  }

  private boolean isClientAlive(ClientID cid) {
    if (!this.channelManager.isActiveID(cid)) {
      logger.warn("Lock Manager ignoring message received from dead client:" + cid);
      return false;
    }
    return true;
  }

  private boolean isValidStateFor(LockID lid, ClientID cid, ThreadID tid, String callType) {
    statusLock.readLock().lock();
    try {
      if (!isStarted) { throw new AssertionError(callType + " message received when lock manager was starting"
                                                 + " Message Context: [LockID=" + lid + ", NodeID=" + cid
                                                 + ", ThreadID=" + tid + "]"); }
      return true;
    } finally {
      statusLock.readLock().unlock();
    }
  }

  private boolean isStarted() {
    statusLock.readLock().lock();
    try {
      return isStarted;
    } finally {
      statusLock.readLock().unlock();
    }
  }

  @Override
  public void addStateTo(final StateDumpCollector stateDumpCollector) {
    try {
      ObjectMapper mapper = new ObjectMapper();
      ObjectNode componentState = mapper.createObjectNode();
      ArrayNode lockNodes = mapper.createArrayNode();
      int size = 0;
      LockIterator iter = lockStore.iterator();
      ServerLock lock = iter.getNextLock(null);
      while (lock != null) {
        lockNodes.add(String.valueOf(lock));
        size++;
        lock = iter.getNextLock(lock);
      }
      componentState.put("Number of locks", size);
      componentState.set("Locks", lockNodes);
      stateDumpCollector.addState(StateDumpCollector.JSON_STATE_KEY, mapper.writerWithDefaultPrettyPrinter()
          .writeValueAsString(componentState));
    } catch (Exception e) {
      stateDumpCollector.addState("exception", e.getLocalizedMessage());
    }
  }

  public PrettyPrinter prettyPrint(PrettyPrinter out) {
    out.print(this.getClass().getName()).flush();
    int size = 0;
    LockIterator iter = lockStore.iterator();
    ServerLock lock = iter.getNextLock(null);
    while (lock != null) {
      out.visit(lock);
      size++;
      lock = iter.getNextLock(lock);
    }
    out.indent().print("locks: " + size).println().flush();
    return out;
  }

  private void assertStateIsStarting(String errMessage) {
    statusLock.readLock().lock();
    try {
      Assert.assertTrue(errMessage, !isStarted);
    } finally {
      statusLock.readLock().unlock();
    }
  }

  private static class RequestLockContext {
    private final LockID          lockID;
    private final ClientID        nodeID;
    private final ThreadID        threadID;
    private final ServerLockLevel requestedLockLevel;
    private final RequestType     type;
    private final long            timeout;

    public RequestLockContext(LockID lockID, ClientID nodeID, ThreadID threadID, ServerLockLevel requestedLockLevel,
                              RequestType type, long timeout) {
      this.lockID = lockID;
      this.nodeID = nodeID;
      this.threadID = threadID;
      this.requestedLockLevel = requestedLockLevel;
      this.type = type;
      this.timeout = timeout;
    }

    public LockID getLockID() {
      return lockID;
    }

    public ClientID getClientID() {
      return nodeID;
    }

    public ThreadID getThreadID() {
      return threadID;
    }

    public ServerLockLevel getRequestedLockLevel() {
      return requestedLockLevel;
    }

    public RequestType getType() {
      return type;
    }

    public long getTimeout() {
      return timeout;
    }

    @Override
    public String toString() {
      return "RequestLockContext [ " + this.lockID + "," + this.nodeID + "," + this.threadID + ","
             + this.requestedLockLevel + ", " + this.type + ", " + this.timeout + " ]";
    }
  }

  /**
   * To be used only in tests
   */
  public int getLockCount() {
    int size = 0;
    ServerLock oldLock = null;
    LockIterator iter = lockStore.iterator();
    ServerLock lock = iter.getNextLock(oldLock);
    while (lock != null) {
      oldLock = lock;
      size++;
      lock = iter.getNextLock(oldLock);
    }
    return size;
  }

  /**
   * To be used only in tests
   */
  public boolean hasPending(LockID lid) {
    AbstractServerLock lock = (AbstractServerLock) lockStore.checkOut(lid);
    boolean result = false;
    try {
      result = lock.hasPendingRequests();
    } finally {
      lockStore.checkIn(lock);
    }
    return result;
  }

  /**
   * To be used only in tests
   */
  public LockHelper getHelper() {
    return lockHelper;
  }

}
