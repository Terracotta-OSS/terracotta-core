#
# All content copyright (c) 2003-2008 Terracotta, Inc.,
# except as may otherwise be noted in a separate copyright notice.
# All rights reserved
#

require 'net/http'
require 'uri'

# Adds methods to BuildSubtree that allow you to run JUnit tests on it. This is probably
# the most complex single file in the entire buildsystem.

# The prefix that we use for dynamically-generated properties -- that is, those that are
# created by the buildsystem out of its own internal information, and not simply information
# manually specified by the user and merely ferried across.
DYNAMICALLY_GENERATED_PROPERTIES_PREFIX = 'tc.tests.info.'

# The prefix that we use for statically-generated properties -- that is, those that are
# specified by the user (or monkey, or configuration file) and simply ferried across to
# the tests.
STATIC_PROPERTIES_PREFIX = 'tc.tests.configuration.'

module PropertyUtils
  def property_string(key, value)
    "#{key.escape}=#{value.escape}"
  end
end

class BuildSubtree
  include PropertyUtils
  
  # Creates a SubtreeTestRun object for this subtree and returns it. Most of the arguments
  # are self-explanatory (they're the obvious instances of the classes with the same names);
  # test_patterns is an array of Ant-style patterns (e.g., "**/*Test") that indicates
  # which tests should be run. aggregation_directory, if non-nil, is a directory into
  # which we should copy the XML result files for all tests. (This is used for
  # CruiseControl, since we want to be able to point it at a single directory of XML
  # log files from test runs, not one per subtree.)
  def test_run(testrun_results, test_patterns, aggregation_directory=nil)
    SubtreeTestRun.new(self, buildconfig_properties, testrun_results, test_patterns, aggregation_directory)
  end

  def container_home
    ENV['TC_CONTAINER_HOME']
  end

  def create_dynamic_property(key, value)
    DYNAMICALLY_GENERATED_PROPERTIES_PREFIX + property_string(key, value)
  end

  # Creates a property file (in the style of java.util.Properties.load()) that contains all
  # the information necessary for the TestConfigObject to do its job and return the
  # appropriate information.
  def create_build_configuration_file(static_resources, testrun_results, build_results, build_environment, config_source, boot_jar, ant, jvm, jvmargs, timeout)
    File.open(testrun_results.build_configuration_file(self).to_s, "w") do |file|
      file << "# Dynamic properties: pieces of information generated by the buildsystem and passed to the Java code\n"
      # The root of the classname-based directory hierarchy used for temporary files created by tests
      write_dynamic_property(file, "temp-root", testrun_results.temp_dir(self))
      # The root of the classname-based directory hierarchy used for data files that tests need
      write_dynamic_property(file, "data-root", build_test_data_directory(testrun_results, ant))
      # The CLASSPATH that should be used for the LinkedChildProcess; this needs to be quite minimal (which
      # is why that class is pretty much in its own module), as it's in the CLASSPATH used to run application
      # servers -- and they typically don't like it if you put random stuff in their CLASSPATH that isn't
      # their own classes.
      common_classpath = build_module.module_set['common'].subtree('tests.base').classpath(build_results, :module_only, :runtime)
      linked_child_process_jars = common_classpath.grep(/linked-child-process.*\.jar$/)
      if linked_child_process_jars.empty?
        fail("Could not find linked-child-process JAR")
      elsif linked_child_process_jars.size > 1
        fail("ERROR: There is more than one linked-child-processs JAR in the CLASSPATH for module common")
      end
      write_dynamic_property(file, "linked-child-process-classpath", linked_child_process_jars.first)

      if container_home
        write_dynamic_property(file, "appserver.home", container_home)
      end

      # Writes out the location of the boot JAR for this tree, if one was created.
      write_dynamic_property(file, "bootjars.normal", boot_jar.path) unless boot_jar.nil?

      # The timeout the tests are going to use. This does *not* actually set the timeout;
      # that's set in the Ant <junit> task. Rather, this is so that the test can fire off
      # a thread dump before it's timed out.
      write_dynamic_property(file, "junit-test-timeout-inseconds", (timeout/1000))

      # The JVM version (e.g., "1.4.2_07"), type (e.g., "hotspot"), and mode (e.g., "client" or "server")
      # that should be used. This is used for a couple tests we have checked in, which make sure they're
      # running with the VM we think they should be running with. (Without them, we are just relying on
      # the buildsystem to spawn the right VM and get it right with no checks; this is a recipe for getting
      # it quite wrong. In fact, these tests already caught a bug; we used to run either with '-server' or
      # without '-server', but never with '-client'. 1.5 decides to pick a VM based on the machine's RAM
      # capacity, number of CPUs, and so on, and so it actually picked server even when we didn't request it.
      # Long story short, you should keep those tests around, and use this code, because it actually
      # really does make a difference.)
      write_dynamic_property(file, "jvm.version", jvm.actual_version)
      write_dynamic_property(file, "jvm.type", jvm.actual_type)
      write_dynamic_property(file, "jvm.mode", (jvmargs.any? { |x| x =~ /-server/i }) ? "server" : "client")

      # Write out the properties that control how the L2 is started.  Since the L2 requires
      # a 1.5 or higher JVM, it must be started in an external JVM if the current JVM is 1.4.
      if jvm.version >= '1.5.0'
        server_jvm = jvm
      else
        server_jvm = Registry[:jvm_set].find_jvm(:min_version => '1.5.0')
      end
      fail("Can't find JVM 15 or greater to run L2") unless server_jvm
      write_dynamic_property(file, "l2.startup.jvm", server_jvm.home.to_s)

      if jvm.version < '1.5.0'
        write_dynamic_property(file, "l2.startup.mode", "external")
      else
        write_dynamic_property(file, "l2.startup.mode", "internal")
      end

      # Write out JAVA_HOME_15 and JAVA_HOME_16
      write_dynamic_property(file, "JAVA_HOME_15", Registry[:jvm_set]['1.5'].home)
      write_dynamic_property(file, "JAVA_HOME_16", Registry[:jvm_set]['1.6'].home)

      if Registry[:emma]
        write_dynamic_property(file, "emma.lib", Registry[:emma_lib])
      end

      # Write out which variant values are available for each variant name, and write out which libraries
      # should be included if the given variant is set to each of the possible values. Right now, this is
      # *all* that variants do -- they do not *ever* actually change the CLASSPATH of what we spawn, because
      # they're only needed for container tests right now (and container tests spawn their own VMs and thus
      # just read these properties directly).
      full_all_variants.each do |variant_name, variant_values|
        write_dynamic_property(file, "variants.available.#{variant_name}", variant_values.join(","))
        variant_values.each do |variant_value|
          write_dynamic_property(file, "libraries.variants.#{variant_name}.#{variant_value}",
            full_variant_libraries(variant_name, variant_value))
        end
      end

      # Writes out the 'short path temporary directory', which is used by the container code to put
      # app servers into a directory that has a shorter pathname prefix. This is so that Windows,
      # which sucks all kinds of ass, doesn't screw us with its limitations on pathname length.
      if build_environment.has_pathname_length_limitations? && (! config_source['SHORT_PATH_TEMPDIR'].blank?)
        write_dynamic_property(file, "short-path-tempdir", config_source['SHORT_PATH_TEMPDIR'])
      end

      # Writes out all static properties -- these are ones that start with 'tc.tests.configuration.', and
      # are merely passed through from the configuration source (typically the command line and build-config.(local|global)
      # files) to the TestConfigObject).
      file << "\n"
      file << "# Static properties: those specified manually by the user or CruiseControl configuration, not the buildsystem\n"
      write_static_properties(file, config_source)
    end
  end

  protected
  # Copies all test data for this subtree to the given directory.
  def copy_subtree_test_data_to_directory(dest_directory, ant)
    out = 0

    if FileTest.exist?(test_data_source_directory.to_s)
      out += 1
      ant.copy(:todir => dest_directory.to_s) {
        ant.fileset(:dir => test_data_source_directory.to_s)
      }
    end

    out
  end

  # Copies all test data for this subtree, and for any subtrees in the same build module that
  # it's dependent upon, to the given directory.
  def copy_module_test_data_to_directory(dest_directory, ant)
    out = 0

    @internal_dependencies.each do |internal_dependency|
      out += build_module.subtree(internal_dependency).copy_subtree_test_data_to_directory(dest_directory, ant)
    end

    out += copy_subtree_test_data_to_directory(dest_directory, ant)
    out
  end

  private
  # Writes out a 'dynamic' property -- one starting with the DYNAMICALLY_GENERATED_PROPERTIES_PREFIX --
  # to the given file.
  def write_dynamic_property(file, key, value)
    file << "#{create_dynamic_property(key, value)}\n"
  end

  # Writes out all properties that start with the STATIC_PROPERTIES_PREFIX from the given
  # configuration source to the given file.
  def write_static_properties(file, config_source)
    config_source.keys.each do |key|
      if key.starts_with?(STATIC_PROPERTIES_PREFIX)
        file << property_string(key, config_source[key]) + "\n"
      end
    end
  end

  # Where is the build configuration file, that contains settings that affect how we
  # run tests on this subtree?
  def test_buildconfig_file
    FilePath.new(build_module.root, @name + ".buildconfig")
  end

  # The directory that data files for this subtree are found in.
  def test_data_source_directory
    FilePath.new(build_module.root, @name + ".data")
  end

  # Computes the build-configuration properties, which affect how we run tests on this
  # subtree. These are read from a properties-style file at <module>/<subtree>.buildconfig,
  # if it exists; otherwise, they're empty. Returns a hash.
  def buildconfig_properties
    if @buildconfig_properties.nil?
      @buildconfig_properties = { }
      filepath = test_buildconfig_file.to_s
      if File.file?(filepath)
        File.open(filepath) do |file|
          lineno = 1
          file.each do |line|
            if line =~ /^\s*(\S[^=]+?)\s*=\s*(\S.*?)\s*$/
              @buildconfig_properties[$1] = $2
            elsif line =~ /^\s*#.*$/ || line =~ /^\s*$/
              # Nothing here
            else
              raise "#{filepath}:%d: Line is an invalid format: #{line}" % [ lineno ]
            end

            lineno += 1
          end
        end
      end
    end

    @buildconfig_properties
  end

  # Builds the test-data directory, which contains test data for this subtree and any
  # subtree this subtree is dependent upon. This is so that test code can ask for the data
  # directory and know it'll get its data, rather than having to make sure it's only when
  # it's running tests from the actual subtree it's in.
  def build_test_data_directory(testrun_results, ant)
    dir = testrun_results.tests_data_dir(self)

    directories_copied_from = copy_all_test_data_to_directory(dir, ant)
    if directories_copied_from > 0
      word = "director" + (directories_copied_from == 1 ? "y" : "ies")
      puts("Compiled test data from #{directories_copied_from} #{word} into '#{dir}' for tests on '#{module_subtree_name}'.")
    else
      puts "No data directories found for '#{module_subtree_name}', or its dependencies."
    end
    dir
  end

  # Copies all test data to the given directory, from this subtree and all the subtrees
  # it's dependent upon.
  def copy_all_test_data_to_directory(dest_directory, ant)
    out = 0

    build_module.dependent_modules.each do |dependent_module|
      out += dependent_module.subtree(@external_dependencies_like).copy_module_test_data_to_directory(dest_directory, ant)
    end

    out += copy_module_test_data_to_directory(dest_directory, ant)
    out
  end
end

# A SubtreeTestRun object is what actually runs tests on a tree. Basically, you ask a BuildSubtree
# to create one for you, and you can then use it to set up for tests, run tests, prepare to run
# them externally (i.e., in Eclipse), or have it print out how it would run tests. This therefore
# encapsulates all test set-up, run, and tear-down logic into a single place so that you can do
# whatever you want with it.
class SubtreeTestRun
  include PropertyUtils
  include BuildData

  # The default timeout for tests, in seconds. Currently, this is 15 minutes.
  DEFAULT_TEST_TIMEOUT_SECONDS = 15 * 60

  # Creates a new instance. Most of the parameters should be obvious; they're just references
  # to the obvious instances of the similarly-named classes. buildconfig is the build-configuration
  # hash (see BuildSubtree#buildconfig_properties, above); test_patterns is an array of Ant-style
  # patterns indicating which tests should be run, and aggregation_directory is a directory to
  # copy the result XML files into when we're done running tests.
  def initialize(subtree, buildconfig, testrun_results, test_patterns, aggregation_directory)
    @subtree = subtree
    @build_module = @subtree.build_module
    @static_resources = Registry[:static_resources]
    @buildconfig = buildconfig
    @testrun_results = testrun_results
    @test_patterns = test_patterns
    @build_results = Registry[:build_results]
    @build_environment = Registry[:build_environment]
    @config_source = Registry[:config_source]
    @internal_config_source = Registry[:internal_config_source]
    @ant = Registry[:ant]
    @platform = Registry[:platform]
    @aggregation_directory = aggregation_directory
    @use_dso_boot_jar = buildconfig['include-dso-boot-jar'] =~ /^\s*true\s*$/i
    @needs_dso_boot_jar = @use_dso_boot_jar || (buildconfig['build-dso-boot-jar'] =~ /^\s*true\s*$/i)
    @timeout = (@config_source["test_timeout"] || buildconfig["timeout"] || DEFAULT_TEST_TIMEOUT_SECONDS.to_s).to_i * 1000

    # add 10m to timeout if running on slow mo Solaris
    if @build_environment.os_type(:nice) =~ /Solaris/
      @timeout += (10 * 60 * 1000)
    end

    @extra_jvmargs = @config_source.as_array('jvmargs') || []
    if buildconfig['jvmargs']
      jvmargs = buildconfig['jvmargs'].split(/\s*,\s*/)
      # Make sure the heap size settings in the buildconfig override the
      # global heap size settings.
      jvmargs.each do |jvmarg|
        if match = /-Xm([sx])/.match(jvmarg)
          @extra_jvmargs.delete_if { |arg| arg =~ /-Xm#{match[1]}/ }
        end
        @extra_jvmargs << jvmarg
      end
    end

    if test_props = buildconfig['test.tc.properties']
      props_file = FilePath.new(@build_results.classes_directory(@subtree), test_props).canonicalize
      @extra_jvmargs << "-Dcom.tc.properties=#{props_file.to_propertyfile_escaped_s}"
    end
  end

  # Returns true if this test run requires a container to run.
  def requires_container?
    @requires_container ||= @buildconfig['requires-container'] =~ /^\s*true\s*$/i
  end

  # Does all preparations necessary to run the given set of tests.
  def setUp

    @has_tests = @subtree.source_exists
    if @has_tests
      @found_tests = find_tests
      @has_tests = ! @found_tests.empty?
    end

    # Skip preparations if we're not actually running any tests on this tree; doing things
    # like building the DSO boot JAR takes time, and it's pointless if we're not actually
    # going to run any tests on this tree (which we might not do depending on how the
    # patterns are set...).
    if ! @has_tests
      @setUp = true
      return
    end

    # tests_jvm will raise an exception if there is a problem with the JVM configuration
    tests_jvm

    if tests_jvm.actual_type =~ /ibm/i
      @extra_jvmargs << "-Xdump:java:file=-"
    end

    add_debug_jvmargs

    puts "------------------------------------------------------------------------"
    puts "PREPARING to run tests (#{@test_patterns.join(", ")}) on subtree '#{@subtree.module_subtree_name}'..."
    puts ""

    # We run the tests with CWD set to the temporary directory, just in case the
    # test decides to just new up files directly (without using the temporary-directory
    # stuff) and write them.
    @cwd = @testrun_results.temp_dir(@subtree)
    @classpath = @subtree.classpath(@build_results, :full, :runtime)

    edition = (@classpath.to_s =~ /ent-common/) ? 'Enterprise' : 'Opensource'
    @build_data_dir = FilePath.new(@cwd, "builddata").ensure_directory
    create_data_file(@config_source, @build_data_dir, :build_data, edition)
    
    # Build a DSO boot JAR, if necessary.
    boot_jar = nil
    if @needs_dso_boot_jar
      if @config_source['boot_jar_path']
        loud_message("Using user specified boot JAR at #{@config_source['boot_jar_path']}")
        boot_jar = UserBootJar.new(@config_source['boot_jar_path'])
      else
        module_set = @subtree.build_module.module_set
        boot_jar_config_file = @subtree.boot_jar_config_file(@static_resources)

        boot_jar_base_dir = @build_results.shared_boot_jar_directory
        if boot_jar_config_file == @static_resources.dso_boot_jar_config_file
          boot_jar_dir = FilePath.new(boot_jar_base_dir, 'standard')
        else
          basename = Regexp.new(BuildSubtree::BOOT_JAR_CONFIG_FILE_BASENAME)
          subdir = "#{@subtree.build_module.name}-#{boot_jar_config_file.filename.to_s.gsub(basename, '')}"
          boot_jar_dir = FilePath.new(boot_jar_base_dir, subdir)
        end

        boot_jar = BootJar.new(tests_jvm, boot_jar_dir, module_set, boot_jar_config_file.to_s)
        boot_jar.add_extra_classpath(@build_data_dir)

        reuse_boot_jars = (@config_source[STATIC_PROPERTIES_PREFIX + 'reuse_boot_jars'] =~ /true/i) ? true : false
        boot_jar_up_to_date = boot_jar.exist? &&
          (File.mtime(boot_jar.path.to_s) > File.mtime(boot_jar_config_file.to_s))
        if reuse_boot_jars && boot_jar_up_to_date
          puts("Using existing boot JAR at #{boot_jar.path}")
        else
          puts("This subtree requires a DSO boot JAR to run tests. Building boot JAR using config file #{boot_jar_config_file}")
          begin
            boot_jar_create_time =  time do boot_jar.ensure_created(:delete_existing => !reuse_boot_jars) end
            puts("Boot JAR creation took #{boot_jar_create_time} seconds")
          rescue => e
            error_msg = "Failed to create boot JAR for: #{@test_patterns.join(", ")} under module " +
              @subtree.build_module.name + ".  Exception: #{e}"
            STDERR.puts(error_msg)
            raise(error_msg)
          end
        end

        # there's a strange bug with FileUtils when Emma is enabled.
        # it won't copy file correctly. We have to use shell cp cmd
        if Registry[:emma]
          from = boot_jar.path.to_s.gsub(/\\/, "/")
          to   = @testrun_results.boot_jar_directory(@subtree).ensure_directory.to_s.gsub(/\\/, "/")

          if ENV['OS'] =~ /Windows/i
            from = `cygpath -u #{from}`.chomp
            to = `cygpath -u #{to}`.chomp
          end
          `cp #{from} #{to}`
        else
          FileUtils.copy(boot_jar.path.to_s, @testrun_results.boot_jar_directory(@subtree).ensure_directory.to_s)
        end
      end
    end

    # This is necessary to make Log4J behave correctly. Ah, Log4J is insane.
    if FileTest.exist?(@static_resources.log4j_properties_file.to_s)
      @ant.copy(:file => @static_resources.log4j_properties_file.to_s, :todir => @testrun_results.temp_dir(@subtree).to_s)
    end

    # download appserver and set appserver.home if needed
    download_appserver_if_needed()

    # Set the tc.tests.configuration.transparent-tests.mode property if necessary
    if mode = @config_source['test.mode']
      @internal_config_source['tc.tests.configuration.transparent-tests.mode'] = mode
    end

    # This creates the file that TestConfigObject reads.
    @subtree.create_build_configuration_file(@static_resources, @testrun_results, @build_results, @build_environment, @config_source, boot_jar, @ant, tests_jvm, all_jvmargs, @timeout)

    native_library_path = @subtree.native_library_path(@build_results, @build_environment, :full)

    @jvmargs = [ ]

    modules_dir = @build_results.modules_home

    # 'tc.tests.info.property-files' is set so that TestConfigObject knows which file to go read.
    @sysproperties = {
      'tc.base-dir' => @static_resources.root_dir.to_s,
      'java.awt.headless' => true,
      'tc.tests.info.property-files' => @testrun_results.build_configuration_file(@subtree).to_s,
      'com.tc.l1.modules.repositories' => modules_dir
    }

    @sysproperties['java.library.path'] = native_library_path.to_s unless native_library_path.to_s.blank?

    if @use_dso_boot_jar
      @jvmargs << "-Xbootclasspath/p:#{boot_jar.path.to_s}"
      @sysproperties.merge!({
          'tc.config' => @static_resources.dso_test_runtime_config_file,
          'tc.dso.globalmode' => false
        })
    end

    # This is *quite* important. If something goes really wrong with a test, to the point where it
    # crashes, doesn't even get started, hangs hard-core, or otherwise can't write out its result
    # XML file, then, without this, we'll never know about it -- which is really, really bad.
    # Instead, we write out these "test didn't run" XML files ahead of time, and let the tests
    # overwrite them as they go; this way, it's positive, instead of negative, feedback -- we only
    # count the test as having passed if we *know* it passed, rather than only counting it as
    # having failed if we *know* it failed. Much better.
    puts "Writing out 'did-not-run' XML files for the #{@found_tests.size} " +
      "test(s) in #{@subtree.build_module.name}/#{@subtree.name}..."
    @found_tests.each do |found_test|
      class_name = @build_results.class_name_for_class_file(@subtree, found_test)
      unless FilePath.new(found_test).filename =~ /\$/
        create_did_not_run_file(class_name, @testrun_results.results_file(@subtree, class_name))
      end
    end

    puts "Done."

    @setUp = true
  end

  def download_appserver_if_needed
    return unless requires_container?
    appserver_home = @config_source['tc.tests.configuration.appserver.home']
    if appserver_home
      if File.exist?(appserver_home)
        puts "** Appserver home is specified #{appserver_home}"
        return
      else
        fail("Appserver home specified [#{appserver_home}] but path not found!")
      end
    end

    urls = @config_source['tc.tests.configuration.appserver.repository'].to_s.split(/,/)
    fail("Neither [tc.tests.configuration.appserver.home] OR [tc.tests.configuration.appserver.repository] was specified!") unless urls

    appserver = @config_source['tc.tests.configuration.appserver.factory.name'] + "-" +
      @config_source['tc.tests.configuration.appserver.major-version'] + "." +
      @config_source['tc.tests.configuration.appserver.minor-version']

    cache_location = @build_environment.os_type(:nice) =~ /windows/i ? 'c:/temp/appservers' : "#{ENV['HOME']}/.tc/appservers"

    appserver_home = File.join(cache_location, appserver)
    if File.exist?(appserver_home)
      puts "** Found cached version of #{appserver} at #{cache_location}"
    else
      FilePath.new(cache_location).ensure_directory
      os_name = @build_environment.os_type(:nice).downcase
      os_name = "win32" if os_name =~ /windows/
      # pick a URL that is live
      url = nil
      urls.each do | u |
        testurl = "#{u}/#{@config_source['tc.tests.configuration.appserver.factory.name']}/#{os_name}/#{appserver}.zip"
        if is_live?(testurl)
          url = testurl
          break
        end
      end

      fail("Can't find any URL that container appserver #{appserver}") unless url

      appserver_zip_path = appserver_home + ".zip"
      @ant.get(:src => url, :dest => appserver_zip_path)
      # we don't use @ant.unzip because it doesn't preserve executable bit of .sh files
      @ant.exec(:executable => "jar", :dir => cache_location) do
        @ant.arg(:value => "xvf")
        @ant.arg(:value => appserver_zip_path)
      end
      @ant.delete(:file => appserver_zip_path)
    end
    @internal_config_source['tc.tests.configuration.appserver.home'] = appserver_home
  end

  # The list of system properties that *must* be set directly on the spawned JVM, rather than
  # being able to be set by TestConfigObject calling System.setProperty() from its static
  # initializer block. These are system properties that the JVM itself reads, or that DSO
  # (which loads from the bootclasspath, long, long before TestConfigObject loads) uses.
  #
  # It's also just a bad idea in the case of running tests in Eclipse, the use of this variable
  # is commented out below; there is a comment there.
  NON_CLASSPATH_LOADABLE_SYSTEM_PROPERTIES = [ 'java.library.path', 'tc.config', 'tc.dso.globalmode', "#{STATIC_PROPERTIES_PREFIX}modules.url" ]

  # Prepares to have tests in this tree run externally (i.e., but Eclipse). This mostly just
  # sets up a properties file that contains a list of system properties for TestConfigObject
  # to set when it's initialized, plus writes out a 'stamp' file indicating which tree
  # we've prepared the tests for.
  #
  # (TestConfigObject loads its file using TestConfigObject.class.getResource(); as such,
  # it loads this file from its own class tree in the filesystem, and so we overwrite it
  # no matter what subtree we're preparing a test run for. Because different subtrees are
  # configured differently and thus will put different things into this file, we have to
  # keep track of what tree we're currently prepared for so that the Eclipse tool that
  # runs Terracotta tests from Eclipse knows whether or not to re-run 'check_prep'.
  #
  # Yes, people have bitched and moaned about this, but it's not remotely clear to me that
  # there's an easier way. If you mandated -- and could enforce -- that every single last
  # test class in the system inherited from TCTestCase, you could have TestConfigObject
  # fetch its resource based on that class, and therefore load the right file...I think.
  # There's still some discussion about whether or not getResource() only looks in the part
  # of the CLASSPATH where the class you called it on was loaded, or if it re-searches
  # the whole CLASSPATH from the top every time. If the latter, then you're *really* screwed.)
  def prepare_for_external_run
    raise "You must call setUp before running this method." unless @setUp

    if ! @has_tests
      return
    end

    test_config_system_properties_file = @build_results.test_config_system_properties_file(@subtree.build_module.module_set)

    # Write out the system properties that we need to set.
    File.open(test_config_system_properties_file.to_s, "w") do |file|
      @sysproperties.each do |key, value|
        file << property_string(key, value) + "\n"
      end
    end

    # Compute which system properties need to be set manually.  This, as it turns out, is a bad idea: the
    # Eclipse plugin for TC development (actually JUnit which it extends) creates an Eclipse launch
    # configuration and it needs ALL the properties since this configuration is reused.  Commented out in
    # case someone really wants to look at this, instead of just removing it.
    #required_system_properties = @sysproperties.keys & NON_CLASSPATH_LOADABLE_SYSTEM_PROPERTIES
    required_system_properties = @sysproperties.keys

    # Write out a file 'stamping' the module and subtree we've prepared this for, plus containing
    # extra information that the Eclipse tool we wrote that runs Terracotta tests needs in order
    # to correctly spawn the JVM that will run the test(s).
    File.open(@build_results.prepped_stamp_file(@subtree.build_module.module_set).to_s, "w") do |file|
      file << "# This file is an indication that 'tcbuild check_prep' has been run.\n"
      file << "tcbuild.prepared.module=#{@subtree.build_module.name.escape}\n"
      file << "tcbuild.prepared.subtree=#{@subtree.name.escape}\n"
      file << "tcbuild.prepared.cwd=#{@cwd.escape}\n"
      file << "tcbuild.prepared.jvm.java=#{tests_jvm.java.escape}\n"
      file << "tcbuild.prepared.jvm.version=#{tests_jvm.actual_version.escape}\n"
      file << "tcbuild.prepared.jvm.type=#{tests_jvm.actual_type.escape}\n"

      jvm_args = all_jvmargs
      if container_home = @subtree.container_home || @config_source['tc.tests.configuration.appserver.home']
        jvm_args << "-D#{@subtree.create_dynamic_property('appserver.home', container_home)}"
      end
      file << "tcbuild.prepared.jvmargs=#{jvm_args.length}\n"

      index = 0
      jvm_args.each do |jvmarg|
        file << "tcbuild.prepared.jvmarg_%d=#{jvmarg.escape}\n" % [ index ]
        index += 1
      end


      required_system_properties.each do |syspropertykey|
        file << "tcbuild.prepared.system-property.#{property_string(syspropertykey, @sysproperties[syspropertykey])}\n"
      end
    end

    puts "========================================================================"
    puts "Wrote required system properties for module #{@subtree.module_subtree_name} to:"
    puts "  '#{test_config_system_properties_file}'."
    puts "The test configuration system will automatically load this file as needed."

    extra = ""
    extra += "  JVM arguments:\n\n"

    unless all_jvmargs.empty?
      all_jvmargs.each { |key| extra += "#{key}\n" }
    end

    unless required_system_properties.empty?
      required_system_properties.each { |key| extra += "-D#{property_string(key, @sysproperties[key])}\n" }
    end

    unless extra.blank?
      puts ""
      puts :warn, "This tree requires certain arguments and system properties that "
      puts :warn, "can't be set at runtime. You should set these directly via your "
      puts :warn, "IDE. If you don't, your tests may or may not work -- you have "
      puts :warn, "been warned."
      puts ""
      puts extra
    end

    puts ""
    puts "And, just FYI (it isn't usually necessary to set these) the buildsystem "
    puts "normally runs tests in #{@subtree.module_subtree_name}..."
    puts "   ...with the current working directory set to:\n\n#{@cwd}\n\n"
    puts "   ...using the Java command at '#{tests_jvm.java}'."
    puts ""
  end

  @@next_failure_property_sequence = 1

  # Runs the tests. script_results is the ScriptResults object, which we inform of any
  # failures we run into.
  def run(script_results)
    raise "You must call setUp before running this method." unless @setUp

    return unless @has_tests

    puts ""
    puts "========================================================================"
    puts "RUNNING tests (#{@test_patterns.join(', ')}) on #{@subtree.module_subtree_name}..."
    puts ""

    failure_properties = [ ]

    junit_formatter_classpath = @build_module.module_set['junit-formatter'].subtree('tests.base').classpath(@build_results, :module_only, :runtime)

    # Run the tests. Most of the real magic here comes in the 'splice_into_ant_junit'
    # method, which puts the necessary <jvmarg>, <sysproperty>, and so forth elements
    # into the junit task.

    begin
      @ant.junit(
        :printsummary => "yes",
        :timeout => @timeout,
        :dir => @cwd.to_s,
        :tempdir => @testrun_results.ant_temp_dir(@subtree).to_s,
        :fork => true,
        :showoutput => true,
        :jvm => tests_jvm.java.to_s) {
        @ant.classpath {
          # add path to TCJUnitFormatter class
          @ant.pathelement( :path => junit_formatter_classpath)
          @ant.pathelement( :path => @build_data_dir.to_s)
        }
        splice_into_ant_junit

        # formatter that outputs result to console
        @ant.formatter(:type => "xml")
        @ant.formatter(:classname => 'com.tc.test.TCJUnitFormatter', :usefile => false)

        # Create a <batchtest> element for each pattern we have.
        @test_patterns.each do |pattern|
          failure_property_name = "tests_failed_%d" % @@next_failure_property_sequence
          @@next_failure_property_sequence += 1
          failure_properties << failure_property_name

          @ant.batchtest(:todir => @testrun_results.results_dir(@subtree).to_s, :fork => true, :failureproperty => failure_property_name) {
            @ant.fileset(:dir => @build_results.classes_directory(@subtree).to_s, :includes => "**/#{pattern}.class")
          }
        end
      }
    rescue
      STDERR.puts "Runtime error: #{$!.message}"
      script_results.failed("Execution of tests in subtree '#{@subtree.module_subtree_name}' failed.")
    ensure
      # clean junit reports of redundant info to help speed up parsing
      # and avoid OOME while parsing big result files
      cleaner = org.terracotta.JUnitReportCleaner.new
      Dir.chdir(@testrun_results.results_dir(@subtree).to_s) do
        Dir.glob("TEST*.xml").each do |filename|
          cleaner.clean(File.expand_path(filename))
        end
      end

      # Aggregate the results into the aggregation directory, if it's set.
      unless @aggregation_directory.nil?
        puts "Copying test result files to '#{@aggregation_directory}'..."
        @ant.copy(:todir => @aggregation_directory.to_s) {
          @ant.fileset(:dir => @testrun_results.results_dir(@subtree).to_s, :includes => '*.xml')
        }
      end
    end
  end


  # Call this when you're all done with tests. It doesn't do anything yet, but it well may in the future.
  def tearDown
    # nothing yet
  end

  # Prints out the arguments and system properties we'd use when running tests on this tree.
  # This can be useful if you want to do something like run the test manually from the
  # command line (e.g., by invoking 'java' directly).
  def dump
    out = "\n\n========================================================================\n"
    out += "When running tests on subtree #{@subtree.module_subtree_name}, the buildsystem will use the following:\n\n"
    out += "  JVM arguments:               #{all_jvmargs.empty? ? '<none>' : all_jvmargs.join(' ')}\n"

    if @sysproperties.empty?
      out += "  System properties:           <none>\n"
    else
      out += "  System properties:           \n"
      @sysproperties.each { |key, value| out += "          -D#{property_string(key, value)}\n" }
    end

    out += "  Timeout:                     #{@timeout} milliseconds\n"
    out += "  Current working directory:   #{@cwd}\n"
    out += "  'java' command:              #{tests_jvm.java}\n\n"
    out += "  CLASSPATH:\n\n#{@classpath}\n\n"

    out
  end

  def get_compatible_vm(appserver)
    Registry[:appserver_compatibility].keys.each do |k|
      if appserver =~ Regexp.new(k)
        return Registry[:appserver_compatibility][k]
      end
    end
    nil
  end


  # Which JVM should we use for this set of tests?
  def tests_jvm(jvm_set = Registry[:jvm_set])
    return @jvm if @jvm

    candidate_source = "[unknown]"

    if candidate = jvm_set['tests-jdk']
      candidate_jvm = candidate
      candidate_source = "'tests-jdk' config override"
    elsif candidate = jvm_set['jdk']
      candidate_jvm = candidate
      candidate_source = "'jdk' config override"
    elsif candidate_name = @buildconfig['tests-jdk']
      candidate_source = "'tests-jdk' override from subtree buildconfig [#{candidate_name}]"
      candidate_jvm = get_required_jvm(candidate_name, candidate_source)
    elsif candidate_name = @buildconfig['jdk']
      candidate_source = "'jdk' override from subtree buildconfig [#{candidate_name}]"
      candidate_jvm = get_required_jvm(candidate_name, candidate_source)
    end

    if candidate_jvm
      override = true
    else
      candidate_jvm = @build_module.jdk
      candidate_source = "modules.def.yml entry for module"
      override = false
    end

    if requires_container?
      current_appserver = Registry[:appserver]
      compatibility = get_compatible_vm(current_appserver) || {
        'min_version' => JavaVersion::JAVA_MIN_VERSION,
        'max_version' => JavaVersion::JAVA_MAX_VERSION
      }
      min_version = JavaVersion.new(compatibility['min_version'])
      max_version = JavaVersion.new(compatibility['max_version'])
      if candidate_jvm.version < min_version || candidate_jvm.version > max_version
        if override
          jvm_version_mismatch(candidate_jvm, candidate_source,
            "appserver #{Registry[:appserver]}",
            compatibility)
        else
          if appserver_candidate_jvm = jvm_set.find_jvm(
              :min_version => compatibility['min_version'],
              :max_version => compatibility['max_version'])
            candidate_jvm = appserver_candidate_jvm
            candidate_source = "appservers.yml entry for #{current_appserver}"
          else
            raise(JvmVersionMismatchException,
              "Could not find JDK compatible with #{Registry[:appserver]},\n" +
                "which requires minimum version #{min_version} and maximum " +
                "version #{max_version}")
          end
        end
      end
    end

    if candidate_jvm.version < @build_module.jdk.min_version
      jvm_version_mismatch(candidate_jvm, candidate_source,
        "module #{@build_module.name}",
        {
          'min_version' => @build_module.jdk.min_version,
          'max_version' => @build_module.jdk.max_version
        })
    else
      puts("JDK version #{candidate_jvm.version} is compatible with module " +
          "#{@build_module.name}, which has minimum version #{@build_module.jdk.min_version}")
    end
    puts("Using JDK #{candidate_jvm} from source #{candidate_source}")
    @jvm = candidate_jvm
  end

  private

  def add_debug_jvmargs
    if debug_port = @config_source['debug']
      unless Integer(debug_port) > 0
        raise "debug argument must be an integer"
      end

      common_options = "server=y,transport=dt_socket,suspend=y,address=#{debug_port}"
      version = tests_jvm.version
      if version >= "1.5.0"
        # Note: this works for IBM JDK too
        @extra_jvmargs << "-agentlib:jdwp=#{common_options}"
      end
    end
  end

  def jvm_version_mismatch(candidate_jvm, candidate_source, thing, compatibility)
    raise(JvmVersionMismatchException,
      "\nActive JDK #{candidate_jvm}\nfrom source #{candidate_source}\n" +
        "is incompatible with #{thing} which requires minimum version " +
        "#{compatibility['min_version']} and maximum version " +
        "#{compatibility['max_version']}")
  end

  def get_required_jvm(name, source)
    jvm = Registry[:jvm_set][name]
    raise("The JDK '#{name}' (from source #{source}) does not exist") unless jvm
    jvm
  end

  # Splice the appropriate elements (CLASSPATH, JVM arguments, system properties,
  # and so on) into Ant.
  def splice_into_ant_junit
    @ant.classpath {
      @ant.pathelement(:location => Registry[:emma_lib]) if Registry[:emma]
      @ant.pathelement(:path => @classpath.to_s)
    }

    if Registry[:emma]
      @jvmargs << '-Demma.coverage.out.merge=true'
      @jvmargs << "-Demma.coverage.out.file=#{Registry[:emma_coverage_dir]}/coverage.ce"
    end

    @jvmargs.each do |jvmarg|
      @ant.jvmarg(:value => jvmarg)
    end

    @sysproperties.each do |key, value|
      @ant.sysproperty(:key => key, :value => value)
    end

    @extra_jvmargs.each do |jvmarg|
      @ant.jvmarg(:value => jvmarg)
    end
  end

  # A description of the patterns we're going to run tests with.
  def patterns_description
    out = ""
    @test_patterns.each do |pattern|
      out += ", " unless out.blank?
      out += "'" + pattern + "'"
    end
    out
  end

  # Figure out which tests we're going to run, as a PathSet.
  def find_tests
    @subtree.classes_matching_patterns(@test_patterns, @ant, @platform, @build_results)
  end

  # The message we write into the 'did-not-run' XML file.
  NOT_RUN_MESSAGE = 'This test, \'%s\', DID NOT RUN. Some problem (i.e. classloader, bootjar, etc) prevents it from starting. Please check the log for error message. '

  # The set of cached Java system properties.
  $cachedJavaProperties = nil

  # Returns a (possibly cached) set of all Java system properties, as a hash. (Caching is
  # safe, because we don't ever set Java system properties from our code.)
  def all_java_properties
    if $cachedJavaProperties.nil?
      $cachedJavaProperties = { }
      iterator = JavaSystem.getProperties.entrySet.iterator
      while iterator.hasNext
        entry = iterator.next
        $cachedJavaProperties[entry.getKey] = entry.getValue
      end
    end

    $cachedJavaProperties
  end

  # Creates a 'did-not-run' XML file for the test with the given class name, and put it in the
  # given target file. This is overwritten by the test once it completes (whether it fails or
  # succeeds); we write it out so that we can make sure we catch the case where the test never
  # completes.
  def create_did_not_run_file(class_name, target_file)
    File.open(target_file.to_s, "w") do |file|
      file << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      file << "<testsuite errors=\"0\" failures=\"1\" name=\"#{class_name.escape(:xml_attribute)}\" tests=\"0\" time=\"0.000\">\n"
      file << "<testcase classname=\"#{class_name.xml_escape}\" name='test' time='0.0'>\n"
      file << ("  <failure type='junit.framework.AssertionFailedError' message=\"" + NOT_RUN_MESSAGE + "\">\n") % class_name.xml_escape(true)
      file << ("      " + NOT_RUN_MESSAGE + "\n") % class_name.xml_escape
      file << "   </failure>\n"
      file << "</testcase>\n"
      file << "<system-out/><system-err/>\n"
      file << "</testsuite>\n"
    end
  end

  # What JVM arguments should we use for these tests?
  def all_jvmargs
    out = @jvmargs || [ ]
    out += @extra_jvmargs unless @extra_jvmargs.empty?
    out
  end
end
