/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. D:/aw/cvs_aw/aspectwerkz4/src/main/org/codehaus/aspectwerkz/expression/ast\grammar.jj */
/*@egen*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

PARSER_BEGIN(ExpressionParser)
/**************************************************************************************
 * Copyright (c) Jonas Bon\u017dr, Alexandre Vasseur. All rights reserved.                 *
 * http://aspectwerkz.codehaus.org                                                    *
 * ---------------------------------------------------------------------------------- *
 * The software in this package is published under the terms of the LGPL license      *
 * a copy of which has been included with this distribution in the license.txt file.  *
 **************************************************************************************/
package org.codehaus.aspectwerkz.expression.ast;

import java.lang.reflect.Modifier;
import java.io.Reader;
import java.io.StringReader;

/**
 * Usage:
 *  <pre>
 *     ExpressionParser parser = new ExpressionParser(System.in); // can be only one
 *     ASTRoot root = parser.parse("call(@RequiresNew public * foo.Bar.*(String, ..) AND withincode(* foo.Baz.within(..)");
 *     Expression expression = new Expression(root);
 *     ...
 *  </pre>
 *
 *
 * TODO: the grammar is still fragile
 *
 * @author <a href="mailto:jboner@codehaus.org">Jonas Bon\u017dr</a>
 * @author <a href="mailto:alex@gnilux.com">Alexandre Vasseur</a>
 * @author <a href="mailto:the_mindstorm@evolva.ro">Alex Popescu</a>
 */
public class ExpressionParser/*@bgen(jjtree)*/implements ExpressionParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTExpressionParserState jjtree = new JJTExpressionParserState();

/*@egen*/

    public ASTRoot parse(String expression) throws ParseException {
        return parse(new StringReader(expression));
    }

    public ASTRoot parse(Reader reader) throws ParseException {
        ReInit(reader);
        return Root();
    }
}
PARSER_END(ExpressionParser)

//------------------ Global lexical scope ------------------
// Note: lexical scope must be <*> and not DEFAULT so that token can be properly reused

<*> SKIP : /* WHITE SPACE */
{
    " "
|
    "\t"
}
<*> TOKEN : /* LOGICAL OPERATORS */
{
    < COMMA: "," >
|
    < DOT: "." >
|
    < #WILDCARD: "*" >
|
    < #ARRAY: "[]" >
|
    < EAGER_WILDCARD: <DOT> <DOT> >
}
TOKEN : /* POINTCUTS */
{
    < AND : "&&" | "and" | "AND" | "&" >
|
    < OR  : "||" | "or"  | "OR"  | "|" >
|
    < NOT : "!" >
|
    < EXECUTION : "execution(" > : METHOD
|
    < CALL : "call(" > : METHOD
|
    < SET : "set(" > : FIELD
|
    < GET : "get(" > : FIELD
|
    < HANDLER : "handler(" > : CLASS
|
    < WITHIN : "within(" > : CLASS
|
    < WITHIN_CODE : "withincode(" > : METHOD
|
    < STATIC_INITIALIZATION : "staticinitialization(" > : CLASS
|
    < CFLOW : "cflow(" >
|
    < CFLOW_BELOW : "cflowbelow(" >
|
    < ARGS : "args(" > : IN_ARGS
|
    < TARGET : "target(" > : CLASS
|
    < THIS : "this(" > : CLASS
|
    < IF : "if()" >
|
    < HAS_METHOD : "hasmethod(" > : METHOD
|
    < HAS_FIELD : "hasfield(" > : FIELD
|
    < POINTCUT_REFERENCE_WITH_ARGS : <POINTCUT_REFERENCE>"(" > : IN_ARGS
|
    < POINTCUT_REFERENCE : (["a"-"z", "A"-"Z", "_", "$", ".", "0"-"9"])+ >
}

//------------------ Lexical scope for classes ------------------

<CLASS> TOKEN :
{
    < CLASS_PRIVATE: "private" >
|
    < CLASS_PROTECTED: "protected" >
|
    < CLASS_PUBLIC: "public" >
|
    < CLASS_STATIC: "static" >
|
    < CLASS_ABSTRACT: "abstract" >
|
    < CLASS_FINAL: "final" >
|
    < CLASS_NOT : "!" >
|
    < CLASS_ATTRIBUTE : "@" <CLASS_EXACT_IDENTIFIER> >
|
    < CLASS_PATTERN: <CLASS_IDENTIFIER> (<DOT> <CLASS_IDENTIFIER>)* >
|
    < #CLASS_EXACT_IDENTIFIER : (<CLASS_JAVA_NAME_LETTER>)+ (<DOT> (<CLASS_JAVA_NAME_LETTER>)+)* >
|
    < #CLASS_IDENTIFIER: (<CLASS_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < #CLASS_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < CLASS_POINTCUT_END: ")" > : DEFAULT
}

//------------------ Lexical scope for methods ------------------

<METHOD> TOKEN :
{
    < METHOD_PUBLIC: "public" >
|
    < METHOD_PROTECTED: "protected" >
|
    < METHOD_PRIVATE: "private" >
|
    < METHOD_STATIC: "static" >
|
    < METHOD_ABSTRACT: "abstract" >
|
    < METHOD_FINAL: "final" >
|
    < METHOD_NATIVE: "native" >
|
    < METHOD_SYNCHRONIZED: "synchronized" >
|
	< TYPE_STATICINITIALIZATION: "staticinitialization" >
|
    < METHOD_NOT : "!" >
|
    < METHOD_ANNOTATION : "@" <METHOD_ATTRIBUTE_EXACT_IDENTIFIER> (<DOT> <METHOD_ATTRIBUTE_EXACT_IDENTIFIER>)* >
| 
    < #METHOD_IDENTIFIER: (<METHOD_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < METHOD_CLASS_PATTERN: <METHOD_IDENTIFIER> (<DOT> <METHOD_IDENTIFIER>)* >
|
    < METHOD_ARRAY_CLASS_PATTERN: <METHOD_CLASS_PATTERN> (<ARRAY>)+ >
|
    < #METHOD_ATTRIBUTE_EXACT_IDENTIFIER: (<METHOD_JAVA_NAME_LETTER>)+ >
|
    < METHOD_PARAMETER_START: "(" >
|
    < METHOD_PARAMETER_END: ")" > : DEFAULT
|
    < #METHOD_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
}

//------------------ Lexical scope for fields ------------------

<FIELD> TOKEN :
{
    < FIELD_PRIVATE: "private" >
|
    < FIELD_PROTECTED: "protected" >
|
    < FIELD_PUBLIC: "public" >
|
    < FIELD_STATIC: "static" >
|
    < FIELD_ABSTRACT: "abstract" >
|
    < FIELD_FINAL: "final" >
|
    < FIELD_TRANSIENT: "transient" >
|
    < FIELD_NOT : "!" >
|
    < FIELD_ANNOTATION : "@" <FIELD_ATTRIBUTE_EXACT_IDENTIFIER> ( <DOT> <FIELD_ATTRIBUTE_EXACT_IDENTIFIER>)* >
|
    < #FIELD_IDENTIFIER: (<FIELD_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < FIELD_CLASS_PATTERN: <FIELD_IDENTIFIER> (<DOT> <FIELD_IDENTIFIER>)* >
|
    < FIELD_ARRAY_CLASS_PATTERN: <FIELD_CLASS_PATTERN> (<ARRAY>)+ >
|
    < #FIELD_ATTRIBUTE_EXACT_IDENTIFIER: (<FIELD_JAVA_NAME_LETTER>)+ >
|
    < #FIELD_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < FIELD_POINTCUT_END: ")" > : DEFAULT
}

//------------------ Lexical scope for parameters ------------------

<PARAMETERS> TOKEN :
{
    < #PARAMETER_IDENTIFIER: (<PARAMETER_JAVA_NAME_LETTER> | <EAGER_WILDCARD> | <WILDCARD>)+ >
|
    < PARAMETER_CLASS_PATTERN: <PARAMETER_IDENTIFIER> (<DOT> <PARAMETER_IDENTIFIER>)* >
|
    < PARAMETER_ARRAY_CLASS_PATTERN: <PARAMETER_CLASS_PATTERN> (<ARRAY>)+ >
|
    < PARAMETER_ANNOTATION: "@" <PARAMETER_IDENTIFIER> >
|
    < #PARAMETER_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < PARAMETER_NOT : "!" >
}

//------------------ Lexical scope for args() ------------------
//which is different from parameters since we do not allow for regexp here
//but only type hierarchy, or starts/endsWith eager pattern
<IN_ARGS> TOKEN :
{
    < #ARG_IDENTIFIER: (<ARG_JAVA_NAME_LETTER>)+ >
|
    < ARG_PATTERN: <ARG_IDENTIFIER> (<DOT> <ARG_IDENTIFIER>)* >
|
    < ARG_ARRAY_PATTERN: <ARG_PATTERN> (<ARRAY>)* >
|
    < #ARG_JAVA_NAME_LETTER: ["a"-"z", "A"-"Z", "_", "$", "+", "#", "0"-"9"] >
|
    < ARGS_END: ")" > : DEFAULT
}

//------------------ Bootstrap ------------------

/**
 * Entry point.
 */
ASTRoot Root()       : {/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Root */
    try {
/*@egen*/
    Expression() <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Expression.
 */
void Expression()             : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    AndExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//------------------ Logical operators ------------------

/**
 * AndExpression.
 */
void AndExpression() : {}
{/*@bgen(jjtree) #And(> 1) */
    {
      ASTAnd jjtn001 = new ASTAnd(JJTAND);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (OrExpression() (LOOKAHEAD(2) <AND> OrExpression())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

/**
 * OrExpression.
 */
void OrExpression() : {}
{/*@bgen(jjtree) #Or(> 1) */
    {
      ASTOr jjtn001 = new ASTOr(JJTOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (UnaryExpression() (LOOKAHEAD(2) <OR> AndExpression())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

/**
 * UnaryExpression.
 */
void UnaryExpression() : {}
{
    NotExpression() | "(" Expression() ")" | Pointcut()
}


/**
 * NotExpression.
 */
void NotExpression() : {}
{
    <NOT>/*@bgen(jjtree) #Not(true) */
          {
            ASTNot jjtn001 = new ASTNot(JJTNOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
          }
          try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
          } catch (Throwable jjte001) {
            if (jjtc001) {
              jjtree.clearNodeScope(jjtn001);
              jjtc001 = false;
            } else {
              jjtree.popNode();
            }
            if (jjte001 instanceof RuntimeException) {
              throw (RuntimeException)jjte001;
            }
            if (jjte001 instanceof ParseException) {
              throw (ParseException)jjte001;
            }
            throw (Error)jjte001;
          } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001, true);
            }
          }
/*@egen*/
}

//------------------ Pointcuts ------------------

/**
 * Pointcut.
 */
void Pointcut() : {}
{
    	Call() 
    |
		Execution()
	|
		WithinCode()
	|
		HasMethod()
	|
		Set()
	|
		Get()
	|
		HasField()
	|
		Within()
	|
	  	Handler()
	|
		Args()
	|
		Target()
	|
		This()
	|
		Cflow()
	|
		CflowBelow()
	|
		StaticInitialization()
	|
	    If()
	|
        PointcutReference()
}

/**
 * Pointcut reference.
 */
void PointcutReference()                    :
{/*@bgen(jjtree) PointcutReference */
    ASTPointcutReference jjtn000 = new ASTPointcutReference(JJTPOINTCUTREFERENCE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token name;
}
{/*@bgen(jjtree) PointcutReference */
    try {
/*@egen*/
    (name=<POINTCUT_REFERENCE_WITH_ARGS> | name=<POINTCUT_REFERENCE>)
    {
        jjtn000.setName(name.image);
    }
    [ ArgsParameters() <ARGS_END> ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Execution.
 */
void Execution()            : {/*@bgen(jjtree) Execution */
  ASTExecution jjtn000 = new ASTExecution(JJTEXECUTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Execution */
    try {
/*@egen*/
    <EXECUTION> 
    (LOOKAHEAD(2) MethodAttribute())*

    (
    	<METHOD_PARAMETER_END>
    |
    	(	
    		LOOKAHEAD(4) ConstructorPattern()
    	|
    		MethodPattern()
		)?
		
		")"
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

/**
 * Call.
 */
void Call()       : {/*@bgen(jjtree) Call */
  ASTCall jjtn000 = new ASTCall(JJTCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Call */
    try {
/*@egen*/
    <CALL> 
    (LOOKAHEAD(2) MethodAttribute())*
    
    (
    	<METHOD_PARAMETER_END>
    |
    	(	
    		LOOKAHEAD(4) ConstructorPattern()
    	|
    		MethodPattern()
		)?
		
		")"
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Set.
 */
void Set()      : {/*@bgen(jjtree) Set */
  ASTSet jjtn000 = new ASTSet(JJTSET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Set */
    try {
/*@egen*/
    <SET> 
    (LOOKAHEAD(2) FieldAttribute())*
    
    (
    	FieldPattern()
    )?
    
    <FIELD_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Get.
 */
void Get()      : {/*@bgen(jjtree) Get */
  ASTGet jjtn000 = new ASTGet(JJTGET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Get */
    try {
/*@egen*/
    <GET> 
    (LOOKAHEAD(2) FieldAttribute())*
    
    (
    	FieldPattern()
    )?
    
    <FIELD_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Handler.
 */
void Handler()          : {/*@bgen(jjtree) Handler */
  ASTHandler jjtn000 = new ASTHandler(JJTHANDLER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Handler */
    try {
/*@egen*/
    <HANDLER> ClassPattern() <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Within.
 */
void Within()         : {/*@bgen(jjtree) Within */
  ASTWithin jjtn000 = new ASTWithin(JJTWITHIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Within */
    try {
/*@egen*/
    <WITHIN> 
    (LOOKAHEAD(2) ClassAttribute())*
    (
    	ClassPattern()
    )?
    <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * WithinCode.
 */
void WithinCode()             : {/*@bgen(jjtree) WithinCode */
        ASTWithinCode jjtn000 = new ASTWithinCode(JJTWITHINCODE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token tkn = null;
}
{/*@bgen(jjtree) WithinCode */
        try {
/*@egen*/
	<WITHIN_CODE>
	(
		WithinStaticInitialization() 
		")"/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/
		{
			jjtn000.setStaticInitializer(true);
		}
	|
		(LOOKAHEAD(2) MethodAttribute())*
		    
		    (
		    	<METHOD_PARAMETER_END>
		    |
		    	(	
		    		LOOKAHEAD(4) ConstructorPattern()
		    	|
		    		MethodPattern()
				)?
				
				")"
		    )
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WithinStaticInitialization()                       : {/*@bgen(jjtree) StaticInitialization */
  ASTStaticInitialization jjtn000 = new ASTStaticInitialization(JJTSTATICINITIALIZATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StaticInitialization */
                try {
/*@egen*/
		<TYPE_STATICINITIALIZATION> 
		<METHOD_PARAMETER_START> 

		(LOOKAHEAD(2) MethodAttribute())*
		(
			StaticInitializationPattern()
		)?
		
		<METHOD_PARAMETER_END>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void StaticInitializationPattern()               :
{/*@bgen(jjtree) ClassPattern */
        ASTClassPattern jjtn000 = new ASTClassPattern(JJTCLASSPATTERN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token tkn = null;
}
{/*@bgen(jjtree) ClassPattern */
        try {
/*@egen*/
	(StaticInitializationPatternModifier())*
	tkn = <METHOD_CLASS_PATTERN>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setTypePattern(tkn.image);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * StaticInitialization.
 */
void StaticInitialization()                       : {/*@bgen(jjtree) StaticInitialization */
  ASTStaticInitialization jjtn000 = new ASTStaticInitialization(JJTSTATICINITIALIZATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StaticInitialization */
    try {
/*@egen*/
    <STATIC_INITIALIZATION> 
    (LOOKAHEAD(2) ClassAttribute())*
    (
    	ClassPattern() 
    )?
    <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Cflow.
 */
void Cflow()        : {/*@bgen(jjtree) Cflow */
  ASTCflow jjtn000 = new ASTCflow(JJTCFLOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Cflow */
   try {
/*@egen*/
   <CFLOW> Expression() ")"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * CflowBelow.
 */
void CflowBelow()             : {/*@bgen(jjtree) CflowBelow */
  ASTCflowBelow jjtn000 = new ASTCflowBelow(JJTCFLOWBELOW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CflowBelow */
   try {
/*@egen*/
   <CFLOW_BELOW> Expression() ")"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * Args.
 */
void Args()       : {/*@bgen(jjtree) Args */
  ASTArgs jjtn000 = new ASTArgs(JJTARGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Args */
    try {
/*@egen*/
    LOOKAHEAD(2)
    <ARGS> <ARGS_END>
    |
    <ARGS> ArgsParameters() <ARGS_END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * HasMethod.
 */
void HasMethod()            : {/*@bgen(jjtree) HasMethod */
  ASTHasMethod jjtn000 = new ASTHasMethod(JJTHASMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HasMethod */
        try {
/*@egen*/
	<HAS_METHOD>
	
    (LOOKAHEAD(2) MethodAttribute())*
    
    (
    	<METHOD_PARAMETER_END>
    |
    	(	
    		LOOKAHEAD(4) ConstructorPattern()
    	|
    		MethodPattern()
		)?
		
		")"
    )/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/**
 * HasField.
 */
void HasField()           : {/*@bgen(jjtree) HasField */
  ASTHasField jjtn000 = new ASTHasField(JJTHASFIELD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) HasField */
   try {
/*@egen*/
   <HAS_FIELD> 
   (LOOKAHEAD(2) FieldAttribute())*
   (
   		FieldPattern()
	)?
	<FIELD_POINTCUT_END>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

/**
 * Target
 */
void Target()        :
{/*@bgen(jjtree) Target */
    ASTTarget jjtn000 = new ASTTarget(JJTTARGET);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token identifier;
}
{/*@bgen(jjtree) Target */
    try {
/*@egen*/
    <TARGET>
    (identifier=<CLASS_PATTERN>)
    {
        jjtn000.setIdentifier(identifier.image);
    }
    <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * This
 */
void This()      :
{/*@bgen(jjtree) This */
    ASTThis jjtn000 = new ASTThis(JJTTHIS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token identifier;
}
{/*@bgen(jjtree) This */
    try {
/*@egen*/
    <THIS>
    (identifier=<CLASS_PATTERN>)
    {
        jjtn000.setIdentifier(identifier.image);
    }
    <CLASS_POINTCUT_END>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * If() marker
 */
void If()    : {/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//------------------ Patterns ------------------

/**
 * Class pattern.
 */
void ClassPattern()               :
{/*@bgen(jjtree) ClassPattern */
    ASTClassPattern jjtn000 = new ASTClassPattern(JJTCLASSPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token pattern;
}
{/*@bgen(jjtree) ClassPattern */
    try {
/*@egen*/
    (ClassModifier())*
    (pattern=<CLASS_PATTERN> | pattern=<EAGER_WILDCARD>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setTypePattern(pattern.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
//    (<CLASS_HIERARCHICAL>
//    {
//        jjtThis.setHierarchical(true);
//    }
//    )*
}

/**
 * Method pattern.
 *
 * @TODO: split class name and method name.
 * @TODO: handle '+'.
 * @TODO: put method name, return type and declaring class in different nodes.
 */
void MethodPattern()                :
{/*@bgen(jjtree) MethodPattern */
    ASTMethodPattern jjtn000 = new ASTMethodPattern(JJTMETHODPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token returnType, name;
}
{/*@bgen(jjtree) MethodPattern */
            try {
/*@egen*/
	    (MethodModifier())*
	    (returnType=<METHOD_CLASS_PATTERN> | returnType=<METHOD_ARRAY_CLASS_PATTERN>)
	    {
	        jjtn000.setReturnTypePattern(returnType.image);
	    }
	    name=<METHOD_CLASS_PATTERN>
	    {
	        jjtn000.setFullNamePattern(name.image);
	    }
	    Parameters()/*@bgen(jjtree)*/
            } catch (Throwable jjte000) {
              if (jjtc000) {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte000 instanceof RuntimeException) {
                throw (RuntimeException)jjte000;
              }
              if (jjte000 instanceof ParseException) {
                throw (ParseException)jjte000;
              }
              throw (Error)jjte000;
            } finally {
              if (jjtc000) {
                jjtree.closeNodeScope(jjtn000, true);
              }
            }
/*@egen*/
}

/**
 * Constructor pattern.
 *
 * @TODO: split class name and constructor name ('new').
 * @TODO: handle '+'.
 * @TODO: put declaring class in a different node.
 */
void ConstructorPattern()                     :
{/*@bgen(jjtree) ConstructorPattern */
    ASTConstructorPattern jjtn000 = new ASTConstructorPattern(JJTCONSTRUCTORPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token name;
}
{/*@bgen(jjtree) ConstructorPattern */
    try {
/*@egen*/
    (ConstructorModifier())*
    name=<METHOD_CLASS_PATTERN>
    {
        if (!name.image.endsWith("new")) {
            throw new RuntimeException("constructor pattern must have 'new' as method name");
        }
        jjtn000.setFullNamePattern(name.image);
    }
    Parameters()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field pattern.
 *
 * @TODO: split class name and field name.
 * @TODO: handle '+'.
 * @TODO: put field name, field type and declaring class in different nodes.
 */
void FieldPattern()               :
{/*@bgen(jjtree) FieldPattern */
    ASTFieldPattern jjtn000 = new ASTFieldPattern(JJTFIELDPATTERN);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token type, name;
}
{/*@bgen(jjtree) FieldPattern */
    try {
/*@egen*/
    (FieldModifier())*
    (type=<FIELD_CLASS_PATTERN> | type=<FIELD_ARRAY_CLASS_PATTERN>)
    {
        jjtn000.setFieldTypePattern(type.image);
    }
    name=<FIELD_CLASS_PATTERN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setFullNamePattern(name.image);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Parameters.
 */
void Parameters() : {}
{
    <METHOD_PARAMETER_START> [Parameter() (<COMMA> Parameter())*] <METHOD_PARAMETER_END>
}

/**
 * Parameter pattern.
 */
void Parameter()            :
{/*@bgen(jjtree) Parameter */
    ASTParameter jjtn000 = new ASTParameter(JJTPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token parameter;
}
{/*@bgen(jjtree) Parameter */
    try {
/*@egen*/
    (parameter=<METHOD_CLASS_PATTERN> | parameter=<METHOD_ARRAY_CLASS_PATTERN> | parameter=<EAGER_WILDCARD>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setTypePattern(parameter.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * ArgsParameters.
 */
void ArgsParameters() : {}
{
    (ArgParameter())? (LOOKAHEAD(2) <COMMA> ArgsParameters())*
}
/**
 * ArgParameter.
 */
void ArgParameter()               :
{/*@bgen(jjtree) ArgParameter */
    ASTArgParameter jjtn000 = new ASTArgParameter(JJTARGPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) ArgParameter */
    try {
/*@egen*/
    (t=<ARG_PATTERN> | t=<ARG_ARRAY_PATTERN> | t=<EAGER_WILDCARD>)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setTypePattern(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Class annotation.
 */
void ClassAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token annotation;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    (<CLASS_NOT>
        {
            jjtn000.toggleNot();
        }
    )*
    annotation=<CLASS_ATTRIBUTE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(annotation.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Method annotation.
 */
void MethodAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token annotation;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    (<METHOD_NOT>
        {
            jjtn000.toggleNot();
        }
    )*
    annotation=<METHOD_ANNOTATION>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(annotation.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field annotation.
 */
void FieldAttribute()            :
{/*@bgen(jjtree) Attribute */
    ASTAttribute jjtn000 = new ASTAttribute(JJTATTRIBUTE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token annotation;
}
{/*@bgen(jjtree) Attribute */
    try {
/*@egen*/
    (<FIELD_NOT>
        {
            jjtn000.toggleNot();
        }
    )*
    annotation=<FIELD_ANNOTATION>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setName(annotation.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Class modifier.
 */
void ClassModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    (<CLASS_NOT>
    {
        jjtn000.toggleNot();
    })*
    (
    <CLASS_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <CLASS_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <CLASS_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <CLASS_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <CLASS_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <CLASS_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Method modifier.
 */
void StaticInitializationPatternModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    (<METHOD_NOT>
    {
        jjtn000.toggleNot();
    })*
    (
    <METHOD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <METHOD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <METHOD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <METHOD_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <METHOD_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <METHOD_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Method modifier.
 */
void MethodModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    (<METHOD_NOT>
    {
        jjtn000.toggleNot();
    })*
    (
    <METHOD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <METHOD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <METHOD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <METHOD_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <METHOD_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <METHOD_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    |
    <METHOD_NATIVE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.NATIVE);
    }
    |
    <METHOD_SYNCHRONIZED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.SYNCHRONIZED);
    }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Constructor modifier.
 */
void ConstructorModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    (<METHOD_NOT>
    {
        jjtn000.toggleNot();
    })*
    (
    <METHOD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <METHOD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <METHOD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <METHOD_SYNCHRONIZED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.SYNCHRONIZED);
    }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/**
 * Field modifier.
 */
void FieldModifier()           : {/*@bgen(jjtree) Modifier */
  ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    (<FIELD_NOT>
    {
        jjtn000.toggleNot();
    })*
    (
    <FIELD_PUBLIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PUBLIC);
    }
    |
    <FIELD_PROTECTED>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PROTECTED);
    }
    |
    <FIELD_PRIVATE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.PRIVATE);
    }
    |
    <FIELD_STATIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.STATIC);
    }
    |
    <FIELD_ABSTRACT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.ABSTRACT);
    }
    |
    <FIELD_FINAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.FINAL);
    }
    |
    <FIELD_TRANSIENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.setModifier(Modifier.TRANSIENT);
    }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
